(window.webpackJsonp=window.webpackJsonp||[]).push([[19],{420:function(a,n,t){"use strict";t.r(n);var e=t(56),o=Object(e.a)({},(function(){var a=this,n=a.$createElement,t=a._self._c||n;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h1",{attrs:{id:"jpa-연관관계의-주인"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#jpa-연관관계의-주인"}},[a._v("#")]),a._v(" JPA 연관관계의 주인")]),a._v(" "),t("h2",{attrs:{id:"manytoone"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#manytoone"}},[a._v("#")]),a._v(" @ManyToOne")]),a._v(" "),t("p",[a._v("가장 일반적으로 사용되는 것이다. 외래키를 가지고 있는 엔티티를 연관관계의 주인으로 사용하는 것.")]),a._v(" "),t("h2",{attrs:{id:"onetomany"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#onetomany"}},[a._v("#")]),a._v(" @OneToMany")]),a._v(" "),t("p",[a._v("OneToMany를 연관관계 주인으로 사용할 수 있음. 하지만, 이렇게 사용할 경우 값을 변경할 때 update쿼리를 한번 더 날려주어야하고, 내가 변경한 테이블에 대한 쿼리가 아닌 다른 테이블로 쿼리가 날라감. 따라서 이것을 사용하는 것보다는 ManyToOne을 사용해주는 것이 좋다.")]),a._v(" "),t("p",[a._v("그리고 OneToMany로 사용할 경우 양방향 구현을 할 때 mappedBy가 지원이 되지 않기 때문에 다른 방법(변경과 같은 것이불가하도록 지정)으로 양방향으로 연결해야한다.ㅓ")]),a._v(" "),t("h2",{attrs:{id:"onetoone"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#onetoone"}},[a._v("#")]),a._v(" @OneToOne")]),a._v(" "),t("p",[a._v("1:1 매핑관계에서 연관관계를 맺어주는 것. 연관관계의 주인은 항상 외래키가 있는 테이블로 밖에 안된다. 즉 주로 사용하는 테이블로 연관관계를 연결해주거나 혹은 주로사용하지 않는 테이블로 연관관계를 맺어줄 수 있음.")]),a._v(" "),t("p",[a._v("자신의 테이블에 있는 외래키에 대해서만 JoinColumn할 수 있음")]),a._v(" "),t("h2",{attrs:{id:"manytomany"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#manytomany"}},[a._v("#")]),a._v(" @ManyToMany")]),a._v(" "),t("p",[a._v("중간 테이블을 생성하여 ManyToMany관계를 풀어줌. 이 방법으로 구현 시 중간테이블을 조절할 수 없기 때문에 절대로 실무에서 사용 불가함."),t("br"),a._v("\n실무에서는 중간테이블이 간단할 수 없기 때문")]),a._v(" "),t("p",[a._v("OneToMany, ManyToOne으로 풀어서 사용해야함. (중간역할을 하는 엔티티를 직접 생성해서)\n이 때 중간 테이블의 외래키 두개를 받아서 사용하는데 두 외래키를 PK로 묶어 사용할지 혹은 따로 FK로 놓고 새로운 PK를 놓아야할지는 구현을 하면서 고민해볼 필요가 있음. 후자를 주로 사용한다고 함.")])])}),[],!1,null,null,null);n.default=o.exports}}]);